<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LMForm - iOS表单配置框架</title>
    <link href="/2020/10/12/LMForm%20-%20iOS%E8%A1%A8%E5%8D%95%E9%85%8D%E7%BD%AE%E6%A1%86%E6%9E%B6/"/>
    <url>/2020/10/12/LMForm%20-%20iOS%E8%A1%A8%E5%8D%95%E9%85%8D%E7%BD%AE%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>通常，将一个页面需要编辑/录入多项信息的页面称为<strong>表单</strong>。iOS 实现表单大多数基于TableView,麻烦的是需要在<code>UITableViewDataSource</code>或者<code>UITableViewDelegate</code>的代理方法中写很多<code>if-else</code>，与cell耦合严重,不易获取用户已编辑的数据。如果表单页面的配置数据从服务端返回，不易实现。</p><a id="more"></a><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>LMForm 是基于MVVM轻量级表单配置框架，把数据和事件整合为一个model，实现cell与model的绑定，只需操作model便可配置表单。项目地址：<a href="https://github.com/MaricleZhang/LMForm.git">https://github.com/MaricleZhang/LMForm.git</a></p><p>![FMForm.png] (<a href="https://upload-images.jianshu.io/upload_images/2403444-945423ece8880410.png">https://upload-images.jianshu.io/upload_images/2403444-945423ece8880410.png</a>)</p><h2 id="2-功能"><a href="#2-功能" class="headerlink" title="2. 功能"></a>2. 功能</h2><ol><li>支持动态配置model来实现表单。</li><li>支持配置文本、输入框、选择器、日期选择、地址选择等。</li><li>支持快速提取数据。</li><li>支持数据校验，可自定义校验格式。</li><li>支持完全自定义cell类型。</li></ol><h2 id="3-预览"><a href="#3-预览" class="headerlink" title="3. 预览"></a>3. 预览</h2><p>![FMForm示例图.gif] (<a href="https://upload-images.jianshu.io/upload_images/2403444-11b8a717ea337fe6.gif">https://upload-images.jianshu.io/upload_images/2403444-11b8a717ea337fe6.gif</a>)</p><h2 id="4-安装"><a href="#4-安装" class="headerlink" title="4. 安装"></a>4. 安装</h2><h3 id="CocoaPods"><a href="#CocoaPods" class="headerlink" title="CocoaPods"></a>CocoaPods</h3><p>在 Podfile 中进行如下导入：</p><pre><code class="hljs nginx"><span class="hljs-attribute">pod</span> <span class="hljs-string">&#x27;LMForm&#x27;</span></code></pre><p>安装</p><pre><code class="hljs cmake">pod <span class="hljs-keyword">install</span></code></pre><h2 id="5-使用"><a href="#5-使用" class="headerlink" title="5. 使用"></a>5. 使用</h2><p>在项目中导入<code>#import &quot;LMForm.h&quot; </code></p><h3 id="1-配置数据源"><a href="#1-配置数据源" class="headerlink" title="1. 配置数据源"></a>1. 配置数据源</h3><p>目前项目中集成以下类型：</p><table><thead><tr><th>类型</th><th>宏定义</th><th>Cell Class</th></tr></thead><tbody><tr><td>文本</td><td>kFormTypeText</td><td>LMFormCell</td></tr><tr><td>输入框</td><td>kFormTypeInput</td><td>LMFormInputCell</td></tr><tr><td>选择器</td><td>kFormTypeSelector</td><td>LMFormSelectorCell</td></tr><tr><td>日期选择器</td><td>kFormTypeDate</td><td>LMDateCell</td></tr><tr><td>地址输入框</td><td>kFormTypeAddressInput</td><td>LMFormAddressInputCell</td></tr></tbody></table><p>可根据需求来选择对应的类型，例如输入框的model配置代码如下：</p><pre><code class="hljs gams">  <span class="hljs-comment">// 输入框</span>- (LMFormModel *)loadInput&#123;    LMFormModel *<span class="hljs-keyword">model</span> = [LMFormModel new];    <span class="hljs-keyword">model</span>.formType = kFormTypeInput;    <span class="hljs-keyword">model</span>.title = @<span class="hljs-string">&quot;手机号&quot;</span>;    <span class="hljs-keyword">model</span>.key = @<span class="hljs-string">&quot;mobile&quot;</span>;    <span class="hljs-keyword">model</span>.value = @<span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-keyword">model</span>.placeholder = @<span class="hljs-string">&quot;请输入手机号&quot;</span>;    <span class="hljs-keyword">model</span>.height = LM_XX_6(<span class="hljs-number">50</span>);    <span class="hljs-keyword">model</span>.message = @<span class="hljs-string">&quot;请输入正确的手机号&quot;</span>;    <span class="hljs-keyword">model</span>.limitLength = <span class="hljs-number">11</span>;    <span class="hljs-keyword">model</span>.validateBlock = ^BOOL(LMFormModel * _Nullable <span class="hljs-keyword">model</span>) &#123;        <span class="hljs-keyword">if</span> (![LMFormValidator isMobile:<span class="hljs-keyword">model</span>.value])        &#123;            [LMWindowHud showHud:<span class="hljs-keyword">model</span>.message];            return <span class="hljs-keyword">NO</span>;        &#125;        return <span class="hljs-keyword">YES</span>;    &#125;;    return <span class="hljs-keyword">model</span>;&#125;</code></pre><p>可根据需要设置UI，输入限制长度，自定义校验等。</p><h3 id="2-创建tableview"><a href="#2-创建tableview" class="headerlink" title="2. 创建tableview"></a>2. 创建tableview</h3><p>创建基于LMFormTableView 的tableview，并且赋值渲染数据，表单的创建完成。</p><pre><code class="hljs ini"><span class="hljs-attr">self.tableView.dataArray</span> = self.dataArray<span class="hljs-comment">;</span></code></pre><h3 id="3-校验数据"><a href="#3-校验数据" class="headerlink" title="3. 校验数据"></a>3. 校验数据</h3><p>提交时，对数据源进行自定义校验，校验的逻辑是对<code>model.validateBlock</code>遍历回调。</p><pre><code class="hljs objectivec"><span class="hljs-comment">/**</span><span class="hljs-comment"> 对数据源校验</span><span class="hljs-comment"></span><span class="hljs-comment"> @param dataArray 数据源</span><span class="hljs-comment"> @return 全部校验通过返回YES，否则返回NO。</span><span class="hljs-comment"> */</span>+ (<span class="hljs-built_in">BOOL</span>)validateDataArray:(<span class="hljs-built_in">NSArray</span>&lt;LMFormModel *&gt; *)dataArray&#123;    <span class="hljs-keyword">for</span> (LMFormModel * _Nonnull obj <span class="hljs-keyword">in</span> dataArray)    &#123;        <span class="hljs-keyword">if</span> (obj.validateBlock)        &#123;            <span class="hljs-keyword">if</span> (!obj.validateBlock(obj)) <span class="hljs-keyword">return</span> <span class="hljs-literal">NO</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-literal">YES</span>;&#125;</code></pre><h3 id="4-获取数据源"><a href="#4-获取数据源" class="headerlink" title="4. 获取数据源"></a>4. 获取数据源</h3><p>因为LMFormTableView中的cell与model绑定，只需遍历获取<code>value</code>即可。</p><h2 id="6-Cell-类型的介绍"><a href="#6-Cell-类型的介绍" class="headerlink" title="6. Cell 类型的介绍"></a>6. Cell 类型的介绍</h2><h3 id="1-LMFormCell"><a href="#1-LMFormCell" class="headerlink" title="1. LMFormCell"></a>1. LMFormCell</h3><p>基类cell:其他类型cell继承该cell，主要功能显示文本，不可编辑。可根据需求配置相应UI和数据。</p><pre><code class="hljs reasonml">- (void)configModel:(LMFormModel *)model&#123;    self.model = model;        <span class="hljs-comment">// data</span>    self.titleLabel.text = model.title;    self.textField.placeholder = model.placeholder;    self.textField.text = model.value;    <span class="hljs-keyword">if</span> (model.limitLength)    &#123;        self.textField.limitLength = @(model.limitLength);    &#125;        <span class="hljs-comment">// UI</span>    self.line.hidden = model.hiddenLine;    self.line.backgroundColor = <span class="hljs-constructor">LM_ObjDefault(<span class="hljs-params">model</span>.<span class="hljs-params">separatorLineColor</span>, LM_UIColorFromHEX(0xF4F4F4)</span>);    self.titleLabel.textColor = <span class="hljs-constructor">LM_ObjDefault(<span class="hljs-params">model</span>.<span class="hljs-params">leftTextColor</span>, LM_UIColorFromHEX(0x666666)</span>);    self.textField.textColor = <span class="hljs-constructor">LM_ObjDefault(<span class="hljs-params">model</span>.<span class="hljs-params">rightTextColor</span>, LM_UIColorFromHEX(0x333333)</span>);    self.titleLabel.font = <span class="hljs-constructor">LM_ObjDefault(<span class="hljs-params">model</span>.<span class="hljs-params">leftLabelFont</span>, [UIFont <span class="hljs-params">systemFontOfSize</span>:LM_XX_6(14)</span>]);    self.titleLabel.font = <span class="hljs-constructor">LM_ObjDefault(<span class="hljs-params">model</span>.<span class="hljs-params">rightLabelFont</span>, [UIFont <span class="hljs-params">systemFontOfSize</span>:LM_XX_6(14)</span>]);&#125;</code></pre><h3 id="2-LMFormInputCell"><a href="#2-LMFormInputCell" class="headerlink" title="2. LMFormInputCell"></a>2. LMFormInputCell</h3><p>输入Cell:可以编辑，可以对输入长度限制，输入的text更新为model的value。</p><pre><code class="hljs mel">- (void)textDidChanged:(UITextField *)<span class="hljs-keyword">textField</span>&#123;    self.model.value = <span class="hljs-keyword">textField</span>.<span class="hljs-keyword">text</span>;    <span class="hljs-keyword">if</span> (self.model.valueDidChangedBlock)    &#123;        self.model.valueDidChangedBlock(<span class="hljs-keyword">textField</span>.<span class="hljs-keyword">text</span>);    &#125;&#125;</code></pre><h3 id="3-LMFormSelectorCell"><a href="#3-LMFormSelectorCell" class="headerlink" title="3. LMFormSelectorCell"></a>3. LMFormSelectorCell</h3><p>选择器Cell:可以选择对应的item,需要配置数据<code>NSArray&lt;NSString *&gt; *selectList</code>,点击cell底部弹窗pickerView</p><pre><code class="hljs ruby">- (void)tapSelectedAction&#123;    LMDefaultPickerView *pickView = [[LMDefaultPickerView alloc] <span class="hljs-symbol">initWithDataArray:</span><span class="hljs-keyword">self</span>.model.selectList];    @weakify(<span class="hljs-keyword">self</span>)    [LMPopupView <span class="hljs-symbol">showPopupViewWithPickView:</span>pickView <span class="hljs-symbol">title:</span><span class="hljs-keyword">self</span>.model.placeholder <span class="hljs-symbol">confirmBlock:</span>^&#123;        @strongify(<span class="hljs-keyword">self</span>)        NSString *text = <span class="hljs-keyword">self</span>.model.selectList[pickView.selectIndex];        <span class="hljs-keyword">self</span>.model.value = text;        <span class="hljs-keyword">self</span>.textField.text = text;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.model.valueDidChangedBlock)        &#123;            <span class="hljs-keyword">self</span>.model.valueDidChangedBlock(text);        &#125;    &#125; <span class="hljs-symbol">cancelBlock:</span>^&#123;            &#125;];&#125;</code></pre><h3 id="4-LMDateCell"><a href="#4-LMDateCell" class="headerlink" title="4. LMDateCell"></a>4. LMDateCell</h3><p>选择日期Cell：与选择cell类似，底部弹窗datePickerView。目前只支持年月日。</p><pre><code class="hljs objectivec">- (<span class="hljs-keyword">void</span>)tapSelectedAction&#123;    @weakify(<span class="hljs-keyword">self</span>)    [LMPopupView showPopupViewWithPickView:<span class="hljs-keyword">self</span>.datePicker title:<span class="hljs-keyword">self</span>.model.placeholder confirmBlock:^&#123;        @strongify(<span class="hljs-keyword">self</span>)        <span class="hljs-built_in">NSDate</span> *date = <span class="hljs-keyword">self</span>.datePicker.date;        <span class="hljs-built_in">NSDateFormatter</span> *formatter = [[<span class="hljs-built_in">NSDateFormatter</span> alloc] init];        [formatter setDateFormat:<span class="hljs-keyword">self</span>.model.dateFormat ?: <span class="hljs-string">@&quot;yyyy-MM-dd&quot;</span>];        <span class="hljs-built_in">NSString</span> *text = [formatter stringFromDate:date];        <span class="hljs-keyword">self</span>.model.value = text;        <span class="hljs-keyword">self</span>.textField.text = text;    &#125; cancelBlock:^&#123;            &#125;];&#125;</code></pre><h3 id="5-LMFormAddressInputCell"><a href="#5-LMFormAddressInputCell" class="headerlink" title="5. LMFormAddressInputCell"></a>5. LMFormAddressInputCell</h3><p>地址输入cell：主要用来输入较多数字的信息，分两行显示。</p><h3 id="6-自定义cell"><a href="#6-自定义cell" class="headerlink" title="6.自定义cell"></a>6.自定义cell</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>LMForm 支持cell的完全自定义，创建的自定义cell需要遵循协议<code>LMFormCellProtocol</code>，<br>协议的方法必须实现，在自定义的cell中实现配置数据。如果LMFormModel中的属性不能满足需求，可以创建LMFormModel分类添加或者继承。个人比较推荐分类的做法。</p><pre><code class="hljs groovy"><span class="hljs-comment">/** 根据model 配置对应的cell  */</span>- (<span class="hljs-keyword">void</span>)<span class="hljs-attr">configModel:</span>(LMFormModel *)model;</code></pre><h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><p>LMForm 维护一张注册表建立key与cellClass的一一对应关系，单例<code>LMFormTypeManager</code>中的<code>keyCellTypes</code>就是这个注册表。注册方法为</p><pre><code class="hljs vbnet">/** 自定义cell时注册方法，同一种cell只需要注册一次。cls 需继承UITableViewCell @param cls cell <span class="hljs-keyword">class</span> @param <span class="hljs-keyword">key</span> <span class="hljs-keyword">key</span> */- (void)registerCellClass:(<span class="hljs-keyword">Class</span>)cls forKey:(NSString *)<span class="hljs-keyword">key</span>;</code></pre><p>需要注意的是注册表是个字典，<strong>key的定义不能重复</strong>。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>客户端配置方法</title>
    <link href="/2019/06/28/%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/"/>
    <url>/2019/06/28/%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="Windows-客户端"><a href="#Windows-客户端" class="headerlink" title="Windows 客户端"></a>Windows 客户端</h2><p><a href="https://mariclezhang.github.io/2019/06/27/Windows%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%85%8D%E7%BD%AE/">https://mariclezhang.github.io/2019/06/27/Windows%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%85%8D%E7%BD%AE/</a></p><a id="more"></a><h2 id="Mac-客户端"><a href="#Mac-客户端" class="headerlink" title="Mac 客户端"></a>Mac 客户端</h2><p><a href="https://mariclezhang.github.io/2019/06/27/Mac%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%85%8D%E7%BD%AE/">https://mariclezhang.github.io/2019/06/27/Mac%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%85%8D%E7%BD%AE/</a></p><h2 id="Andriod-客户端"><a href="#Andriod-客户端" class="headerlink" title="Andriod 客户端"></a>Andriod 客户端</h2><p><a href="https://mariclezhang.github.io/2019/06/27/Android%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%85%8D%E7%BD%AE/">https://mariclezhang.github.io/2019/06/27/Android%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%85%8D%E7%BD%AE/</a></p><h2 id="iOS-客户端"><a href="#iOS-客户端" class="headerlink" title="iOS 客户端"></a>iOS 客户端</h2><p><a href="https://mariclezhang.github.io/2019/06/27/iOS%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%85%8D%E7%BD%AE/">https://mariclezhang.github.io/2019/06/27/iOS%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%85%8D%E7%BD%AE/</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Mac 客户端配置</title>
    <link href="/2019/06/27/Mac%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%85%8D%E7%BD%AE/"/>
    <url>/2019/06/27/Mac%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="下载Mac客户端ShadowsocksR"><a href="#下载Mac客户端ShadowsocksR" class="headerlink" title="下载Mac客户端ShadowsocksR"></a>下载Mac客户端ShadowsocksR</h3><p>下载地址：<a href="https://github.com/qinyuhang/ShadowsocksX-NG-R/releases/download/1.4.4-r8/ShadowsocksX-NG-R8.dmg">https://github.com/qinyuhang/ShadowsocksX-NG-R/releases/download/1.4.4-r8/ShadowsocksX-NG-R8.dmg</a></p><a id="more"></a><h3 id="ShadowsocksR-Mac客户端安装及运行"><a href="#ShadowsocksR-Mac客户端安装及运行" class="headerlink" title="ShadowsocksR Mac客户端安装及运行"></a>ShadowsocksR Mac客户端安装及运行</h3><ol><li>下载完成后，打开dmg文件，双击shadowsocksX-NG-R8。</li></ol><p><img src="https://raw.githubusercontent.com/MaricleZhang/reasource/master/2403444-408751fde9a2011f.png" alt="安装ssr.png"><br>2. 安装完成后，从LaunchPad或应用程序中打开，系统右上角会出现小飞机标志。</p><ol start="3"><li>点击小飞机打开菜单–&gt;服务器–&gt;服务器设置：</li></ol><p><img src="https://raw.githubusercontent.com/MaricleZhang/reasource/master/2403444-3760f31aece7fb86.jpg" alt="添加服务器.jpg"></p><ol start="4"><li>在接下来的窗口中，点击左下侧的 + 号，然后在右侧设置服务器参数，按<strong>所给的账号配置信息</strong>。<br><img src="https://raw.githubusercontent.com/MaricleZhang/reasource/master/2403444-af4c96268cd4dbad.png" alt="配置信息.png"></li><li>打开<a href="http://www.google.com,能打开说明配置成功,可以愉快的翻墙了./">www.google.com，能打开说明配置成功，可以愉快的翻墙了。</a></li></ol><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><ol><li>代理模式最好设置为PAC自动模式，访问国内网站不走代理。<br>操作步骤：右击小飞机图标-&gt;系统代理模式-&gt;PAC模式。</li><li>本代理可以速度很快，可以看720p <a href="https://www.youtube.com/">youtube</a>视频,可以尝试一下。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Windows 客户端配置</title>
    <link href="/2019/06/27/Windows%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%85%8D%E7%BD%AE/"/>
    <url>/2019/06/27/Windows%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="下载Windows客户端ShadowsocksR"><a href="#下载Windows客户端ShadowsocksR" class="headerlink" title="下载Windows客户端ShadowsocksR"></a>下载Windows客户端ShadowsocksR</h3><p>下载地址：<a href="https://github.com/shadowsocksrr/shadowsocksr-csharp/releases/download/4.9.0/ShadowsocksR-win-4.9.0.zip">https://github.com/shadowsocksrr/shadowsocksr-csharp/releases/download/4.9.0/ShadowsocksR-win-4.9.0.zip</a></p><a id="more"></a><h3 id="ShadowsocksR-Windows客户端安装及运行"><a href="#ShadowsocksR-Windows客户端安装及运行" class="headerlink" title="ShadowsocksR Windows客户端安装及运行"></a>ShadowsocksR Windows客户端安装及运行</h3><ol><li><p>SSR下载完成后，解压，然后后运行ShadowsocksR-dotnet2.0.exe 或 ShadowsocksR-dotnet4.0.exe 即可。</p></li><li><p>SSR成功运行后，系统任务栏会出现一个小飞机标志：</p></li></ol><p><img src="https://raw.githubusercontent.com/MaricleZhang/reasource/master/2018-07-17_163552.jpg" alt="小飞机标志.jpg"></p><ol start="3"><li><p>我们需要先添加SSR服务器。右键点击小飞机——服务器——编辑服务器：<br><img src="https://raw.githubusercontent.com/MaricleZhang/reasource/master/2018-07-17_163952.jpg" alt="添加SSR服务器.jpg"></p></li><li><p>在弹出的编辑服务器窗口，直接修改默认的几项参数。修改为之前安装SSR服务端时，设置好的各项信息。其中带 * 号的几项，为必填项。设置完成后，点击确定即可完成服务器的设置。</p></li></ol><p><img src="https://raw.githubusercontent.com/MaricleZhang/reasource/master/WechatIMG35.jpeg" alt="编辑服务器.jpeg"></p><ol start="5"><li>打开<a href="www.google.com">www.google.com</a>，能打开说明配置成功，可以愉快的翻墙了。</li></ol><h3 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h3><ol><li>代理模式最好设置为PAC自动模式，访问国内网站不走代理。<br>操作步骤：右击小飞机图标-&gt;系统代理模式-&gt;PAC模式。</li><li>本代理可以速度很快，可以看720p <a href="https://www.youtube.com/">youtube</a>视频,可以尝试一下。</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Andriod 客户端配置</title>
    <link href="/2019/06/27/Android%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%85%8D%E7%BD%AE/"/>
    <url>/2019/06/27/Android%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="下载Andriod客户端"><a href="#下载Andriod客户端" class="headerlink" title="下载Andriod客户端"></a>下载Andriod客户端</h3><p><a href="https://github.com/shadowsocksrr/shadowsocksr-android/releases/download/3.5.4/shadowsocksr-android-3.5.4.apk">https://github.com/shadowsocksrr/shadowsocksr-android/releases/download/3.5.4/shadowsocksr-android-3.5.4.apk</a></p><a id="more"></a><h3 id="配置SSR"><a href="#配置SSR" class="headerlink" title="配置SSR"></a>配置SSR</h3><ol><li>打开SSR(粉红色图标），出现下图：</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/2403444-c2f6e2af93a91ed1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SSR"></p><ol start="2"><li><p>按所给信息配置：服务器、远端端口、密码、加密方法、协议、混淆方法。<strong>其他的不要动</strong>。</p></li><li><p>配置完成后点击右上角小飞机图标。</p></li><li><p>到浏览器中打开</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS 客户端配置</title>
    <link href="/2019/06/27/iOS%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%85%8D%E7%BD%AE/"/>
    <url>/2019/06/27/iOS%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="下载iOS客户端"><a href="#下载iOS客户端" class="headerlink" title="下载iOS客户端"></a>下载iOS客户端</h3><p>iOS 客户端在appstore 中国大陆地区被封了，所以需要把地区改为“台湾”。<br>步骤：设置–&gt;通用–&gt;语言与地区–&gt;地区–选择台湾。地区设置完成后在apptore中搜索”Potatso Lite”下载即可。</p><a id="more"></a><p><img src="https://upload-images.jianshu.io/upload_images/2403444-b37ef320145c88d5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Potatso Lite.png"></p><h3 id="配置Potatso-Lite"><a href="#配置Potatso-Lite" class="headerlink" title="配置Potatso Lite"></a>配置Potatso Lite</h3><h4 id="方法一：二维码扫描"><a href="#方法一：二维码扫描" class="headerlink" title="方法一：二维码扫描"></a>方法一：二维码扫描</h4><ol><li>打开Potatso Lite，点击添加代理。</li><li>点击二维码扫描。</li><li>点击“开始”。</li><li>浏览器中输入<a href="http://www.google.com,打开则说明连接成功./">www.google.com,打开则说明连接成功。</a></li></ol><p><img src="https://upload-images.jianshu.io/upload_images/2403444-94cc6320a34573bd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10_54_06__07_02_2019.jpg"></p><h4 id="方法二：手动输入"><a href="#方法二：手动输入" class="headerlink" title="方法二：手动输入"></a>方法二：手动输入</h4><ol><li>打开Potatso Lite，点击添加代理。</li><li>选择“手动输入”。</li><li>点击Shadowsocks，下面会弹出选择框，选择ShadowsocksR。</li><li>按照<strong>所给的配置信息</strong>填写，如下。<br><img src="https://upload-images.jianshu.io/upload_images/2403444-32308b7e6492f3ab.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10_53_17__07_02_2019.jpg"></li><li>点击右上角的“对号”，返回到首页如下，点击开始<br><img src="https://upload-images.jianshu.io/upload_images/2403444-94cc6320a34573bd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10_54_06__07_02_2019.jpg"></li><li>浏览器中输入<a href="http://www.google.com,打开则说明连接成功./">www.google.com,打开则说明连接成功。</a></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Mac常用工具</title>
    <link href="/2019/03/19/Mac%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/"/>
    <url>/2019/03/19/Mac%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Mac OS X系统有一段时间了，记录一下开发中优秀的工具。</p><a id="more"></a><h4 id="licecap"><a href="#licecap" class="headerlink" title="licecap"></a>licecap</h4><p>gif录制软件</p><h4 id="Beyond-Compare"><a href="#Beyond-Compare" class="headerlink" title="Beyond Compare"></a>Beyond Compare</h4><p>比较两个文件</p><h4 id="charles"><a href="#charles" class="headerlink" title="charles"></a>charles</h4><p>抓包工具</p><h4 id="XMind-MindNote"><a href="#XMind-MindNote" class="headerlink" title="XMind MindNote"></a>XMind MindNote</h4><p>思维导图 </p><h4 id="starUML"><a href="#starUML" class="headerlink" title="starUML"></a>starUML</h4><p>流程图，时序图</p><h4 id="XMAPP"><a href="#XMAPP" class="headerlink" title="XMAPP"></a>XMAPP</h4><p>建立本地服务器</p><h4 id="foxmail"><a href="#foxmail" class="headerlink" title="foxmail"></a>foxmail</h4><p>邮箱</p><h4 id="sublime"><a href="#sublime" class="headerlink" title="sublime"></a>sublime</h4><p>文本编辑器</p><h4 id="有道云笔记"><a href="#有道云笔记" class="headerlink" title="有道云笔记"></a>有道云笔记</h4><p>记录</p><h4 id="iTools"><a href="#iTools" class="headerlink" title="iTools"></a>iTools</h4><p>查询手机信息，与Mac屏幕实时共享。</p><h4 id="WebStorm"><a href="#WebStorm" class="headerlink" title="WebStorm"></a>WebStorm</h4><p>Material Theme 主题</p><h4 id="SourceTree"><a href="#SourceTree" class="headerlink" title="SourceTree"></a>SourceTree</h4><p>代码管理</p><h4 id="Alfred"><a href="#Alfred" class="headerlink" title="Alfred"></a>Alfred</h4><p>快速检索Mac中的程序，资源。</p><h4 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h4><p>http 请求</p><h4 id="翻墙"><a href="#翻墙" class="headerlink" title="翻墙"></a>翻墙</h4><p>ShadowsocksX-NG</p><h4 id="iOS-崩溃解析工具"><a href="#iOS-崩溃解析工具" class="headerlink" title="iOS 崩溃解析工具"></a>iOS 崩溃解析工具</h4><p>dSYMTools</p><h4 id="iOS-切图app-icon-launch"><a href="#iOS-切图app-icon-launch" class="headerlink" title="iOS 切图app icon launch"></a>iOS 切图app icon launch</h4><p>iconizer</p><h4 id="markdown-书写工具"><a href="#markdown-书写工具" class="headerlink" title="markdown 书写工具"></a>markdown 书写工具</h4><p>MWeb Typora</p><h3 id="下载工具"><a href="#下载工具" class="headerlink" title="下载工具"></a>下载工具</h3><p>Motrix</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>XCode-10-升级问题总结</title>
    <link href="/2018/09/29/XCode-10-%E5%8D%87%E7%BA%A7%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2018/09/29/XCode-10-%E5%8D%87%E7%BA%A7%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="library-not-found-for-lstdc-6-0-9"><a href="#library-not-found-for-lstdc-6-0-9" class="headerlink" title="library not found for -lstdc++.6.0.9"></a>library not found for -lstdc++.6.0.9</h3><p>xcode 10 中删除了内置 <code>libstdc++.6.0.9.tbd</code>，工程中一些SDK依赖这个库，需要把xcode 9.4 的<code>libstdc++.6.0.9.tbd</code> 添加到xcode中，重启xcode。<br>libstdc++.6.0.9.tbd 的下载地址：<a href="https://github.com/MaricleZhang/libstdc-.6.0.9.tbd.git">libstdc++.6.0.9</a></p><a id="more"></a><h4 id="真机"><a href="#真机" class="headerlink" title="真机"></a>真机</h4><pre><code class="hljs awk"><span class="hljs-regexp">/Applications/</span>Xcode.app<span class="hljs-regexp">/Contents/</span>Developer<span class="hljs-regexp">/Platforms/i</span>PhoneOS.platform<span class="hljs-regexp">/Developer/</span>SDKs<span class="hljs-regexp">/iPhoneOS.sdk/u</span>sr<span class="hljs-regexp">/lib/</span></code></pre><h4 id="模拟器"><a href="#模拟器" class="headerlink" title="模拟器"></a>模拟器</h4><pre><code class="hljs awk"><span class="hljs-regexp">/Applications/</span>Xcode.app<span class="hljs-regexp">/Contents/</span>Developer<span class="hljs-regexp">/Platforms/i</span>PhoneOS.platform<span class="hljs-regexp">/Developer/</span>Library<span class="hljs-regexp">/CoreSimulator/</span>Profiles<span class="hljs-regexp">/Runtimes/i</span>OS.simruntime<span class="hljs-regexp">/Contents/</span>Resources<span class="hljs-regexp">/RuntimeRoot/u</span>sr<span class="hljs-regexp">/lib/</span><span class="hljs-regexp">/Applications/</span>Xcode.app<span class="hljs-regexp">/Contents/</span>Developer<span class="hljs-regexp">/Platforms/i</span>PhoneSimulator.platform<span class="hljs-regexp">/Developer/</span>SDKs<span class="hljs-regexp">/iPhoneSimulator.sdk/u</span>sr<span class="hljs-regexp">/lib/</span></code></pre><h3 id="Multiple-commands-produce’-Users-user-Library-Developer-Xcode-DerivedData…"><a href="#Multiple-commands-produce’-Users-user-Library-Developer-Xcode-DerivedData…" class="headerlink" title="Multiple commands produce’/Users/user/Library/Developer/Xcode/DerivedData…"></a>Multiple commands produce’/Users/user/Library/Developer/Xcode/DerivedData…</h3><ul><li><p>#####方法1<br>xcode 10 默认是新的编译模式，选择File &gt; Workspace Settings &gt; Build System &gt; Legacy Build System.，改变为之前的编译模式Legacy Build system。</p></li><li><p>#####方法2<br>Open target -&gt; Build phase &gt; Copy Bundle Resource  删除output files 中的脚本，如果存在 info.plist 也一起删除。</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/2403444-dc2bcdb459d1b5d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="delete_output.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS-消息转发机制</title>
    <link href="/2018/06/27/iOS-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6/"/>
    <url>/2018/06/27/iOS-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<blockquote><p>iOS开发过程中我们经常会碰到这样的报错：unrecognized selector sent to instance ** 原因就是调用一个该对象没有实现的方法。用OC消息机制来说就是：消息的接收者不过到对应的selector，这样就启动了消息转发机制，我们可以通过代码在消息转发的过程中告诉对象应该如何处理未知的消息，默认实现是抛出下面的异常</p></blockquote><a id="more"></a><h3 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h3><p>给一个对象发送一条消息：</p><pre><code class="hljs reasonml"><span class="hljs-literal">[<span class="hljs-identifier">obj</span> <span class="hljs-identifier">messageName</span>:<span class="hljs-identifier">parameter</span>]</span> -&gt; objc<span class="hljs-constructor">_msgSend(<span class="hljs-params">obj</span>,SEL, <span class="hljs-params">parameter</span>)</span></code></pre><ol><li>通过 NSObject 的 isa 指针找到对应的 Class</li><li>在 Class 的方法列表中找到对应的 selector</li><li>如果在当前 Class 中未能找到 selector 则往父类的方法列表中继续查找</li><li>如果能找到对应的 selector 则去执行对象的方法实现（IMP）</li><li>如果还是没找到就要开始进入动态方法解析和消息转发</li></ol><p>在上述流程中如果不能找对对应的 selector 时，这时候就会进入消息转发机制。消息转发机制可分为两个阶段，在这两个阶段中，有 3 次机会来处理之前未能处理 selector，越往后所花费的代价将越大，处理的灵活程度也就越高。如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/2403444-746884faa399cef7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="messageforward.png"></p><h3 id="动态特性：方法解析和消息转发"><a href="#动态特性：方法解析和消息转发" class="headerlink" title="动态特性：方法解析和消息转发"></a>动态特性：方法解析和消息转发</h3><h4 id="动态方法解析阶段"><a href="#动态方法解析阶段" class="headerlink" title="动态方法解析阶段"></a>动态方法解析阶段</h4><p>在该阶段中，可以动态的为类添加一个方法，从而让动态添加的方法来处理之前未能处理的消息。可重写类以下方法：</p><pre><code class="hljs css">+ (<span class="hljs-selector-tag">BOOL</span>)<span class="hljs-selector-tag">resolveInstanceMethod</span><span class="hljs-selector-pseudo">:(SEL)sel</span></code></pre><p>如果是类的静态方法，可重写以下方法：</p><pre><code class="hljs gcode">+ <span class="hljs-comment">(BOOL)</span>resolveClassMethod:<span class="hljs-comment">(SEL)</span>sel</code></pre><p>SEL 就是未能处理的 selector，返回值为 BOOL 表示是否增加了新的方法来处理该 selector</p><h4 id="备援接收阶段"><a href="#备援接收阶段" class="headerlink" title="备援接收阶段"></a>备援接收阶段</h4><p>在该阶段中我们可以将未知的 selector 转发给其他对象来处理。运行时提供两次机会，来做消息的转发，第一次是重写以下方法：</p><pre><code class="hljs erlang">- <span class="hljs-params">(id)</span>forwardingTargetForSelector:<span class="hljs-params">(SEL)</span>aSelector</code></pre><h4 id="完整消息转发"><a href="#完整消息转发" class="headerlink" title="完整消息转发"></a>完整消息转发</h4><p>如果不重写该方法，运行时将把方法调用的所有细节封装到 NSInvocation 对象中，进入完整的消息转发机制中，运行时将继续调用一下方法来进行消息的派发：</p><pre><code class="hljs erlang">- <span class="hljs-params">(NSMethodSignature *)</span>methodSignatureForSelector:<span class="hljs-params">(SEL)</span>aSelector- <span class="hljs-params">(void)</span>forwardInvocation:<span class="hljs-params">(NSInvocation *)</span>anInvocation</code></pre><p>方法中的 NSInvocation 参数，包含了所有方法调用的细节，包括 selector/target/参数 等，重写该方法后我们可以将 anInvocation 转发给多个对象来处理该消息。在该阶段我们可以用来实现 “多重继承” 或者多重代理等。</p><p>如果在两个阶段都不做任何处理的话，运行时将会把 selector 交由 doesNotRecognizeSelector 方法来处理，从而抛出异常导致 Crash </p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><h4 id="崩溃的规避"><a href="#崩溃的规避" class="headerlink" title="崩溃的规避"></a>崩溃的规避</h4><p>创建 <code>NSObject+CashHandle</code>的分</p><pre><code class="hljs objectivec">- (<span class="hljs-built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector&#123;    <span class="hljs-comment">//方法签名</span>    <span class="hljs-keyword">return</span> [<span class="hljs-built_in">NSMethodSignature</span> signatureWithObjCTypes:<span class="hljs-string">&quot;v@:@&quot;</span>];&#125;- (<span class="hljs-keyword">void</span>)forwardInvocation:(<span class="hljs-built_in">NSInvocation</span> *)anInvocation&#123;    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;NSObject+CrashLogHandle---在类:%@中 未实现该方法:%@&quot;</span>,<span class="hljs-built_in">NSStringFromClass</span>([anInvocation.target <span class="hljs-keyword">class</span>]),<span class="hljs-built_in">NSStringFromSelector</span>(anInvocation.selector));&#125;</code></pre><p><a href="https://github.com/MaricleZhang/MessageForwardingDemo.git">Demo</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Pod 私有库的创建及使用</title>
    <link href="/2018/02/12/Pod-%E7%A7%81%E6%9C%89%E5%BA%93%E7%9A%84%E5%88%9B%E5%BB%BA%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
    <url>/2018/02/12/Pod-%E7%A7%81%E6%9C%89%E5%BA%93%E7%9A%84%E5%88%9B%E5%BB%BA%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CocoaPods是iOS项目的依赖管理工具，使用它可以方便的管理和更新项目中所使用到的第三方库，我们一般用的是公有库，代码存放在Github上。个人或公司在开发过程中，会积累很多可以复用的代码包，有些我们不想开源，又想像开源库一样在CocoaPods中管理它们，那么通过私有库来管理就很必要。</p><a id="more"></a><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>在创建私有库之前，我们有必要理解私有库的原理，<br><img src="http://upload-images.jianshu.io/upload_images/2403444-9206906d9b8dc9d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="podfile、索引库和代码库关系图.png"></p><p>Podfile:工程的依赖描述文件。<br>Spec:  该仓库存放索引描述文件.podspec，CocoaPods通过该文件对你真正存储代码工程的 Git 仓库进行索引与下载,下面会有对podspec的详细介绍。通过spec库来控制pod私有库的版本。</p><p>Lib : 你上传到远程Git仓库的代码工程，将来用于开源共享或则私有</p><p>CocoaPods 根据podfile中的库的名称，通过spec索引库，来找到真正的代码库。这里有同学可能要问为什么需要两个仓库呢，我的理解是为了快速检索和版本控制。如果没有spec索引库，我们每次pod update的时候都需要在GitHub所有的代码库中检索。显然效率很低。</p><h2 id="Pod私有库的创建步骤"><a href="#Pod私有库的创建步骤" class="headerlink" title="Pod私有库的创建步骤"></a>Pod私有库的创建步骤</h2><ol><li>创建两个仓库：索引库和代码仓库。</li><li>创建并设置本地私有Spec Repo。</li><li>创建Pod所对应的podspec文件。</li><li>本地测试配置好的podspec文件。</li><li>向私有的Spec Repo中提交podspec。</li></ol><h3 id="创建两个仓库：索引库和代码仓库"><a href="#创建两个仓库：索引库和代码仓库" class="headerlink" title="创建两个仓库：索引库和代码仓库"></a>创建两个仓库：索引库和代码仓库</h3><p>在github上创建索引库 <strong><a href="https://github.com/MaricleZhang/ZJMaricleSpec">ZJMaricleSpec</a>**和代码库</strong><a href="https://github.com/MaricleZhang/ZJMaricle">ZJMaricle</a>**</p><h3 id="创建并设置本地私有Spec-Repo"><a href="#创建并设置本地私有Spec-Repo" class="headerlink" title="创建并设置本地私有Spec Repo"></a>创建并设置本地私有Spec Repo</h3><p>两个仓库创建完成后在Terminal中执行如下命令</p><pre><code class="hljs awk"> <span class="hljs-comment"># pod repo add [Private Repo Name] [GitHub HTTPS clone URL]</span>$ pod repo add ZJMaricleSpec https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/MaricleZhang/</span>ZJMaricleSpec.git</code></pre><p>需要特别注意的是这里的URL是Spec索引库的地址，如果写成代码库的地址就会出现</p><pre><code class="hljs awk">[!] An unexpected version directory Assets was encountered <span class="hljs-keyword">for</span> the <span class="hljs-regexp">/Users/</span>zhangjian<span class="hljs-regexp">/.cocoapods/</span>repos<span class="hljs-regexp">/mariclezhang/</span>YTVestSDK Pod <span class="hljs-keyword">in</span> the YTVestSDK repository.</code></pre><p>执行完成后</p><pre><code class="hljs arcade">$ cd ~<span class="hljs-regexp">/.cocoapods/</span>repos</code></pre><p>如果存在<code>ZJMaricleSpec</code>则说明本地<code>repo Spec</code> 创建成功</p><h3 id="创建Pod所对应的podspec文件"><a href="#创建Pod所对应的podspec文件" class="headerlink" title="创建Pod所对应的podspec文件"></a>创建Pod所对应的podspec文件</h3><p>  cd 到要创建项目的目录然后执行</p><pre><code class="hljs crystal">$ pod <span class="hljs-class"><span class="hljs-keyword">lib</span> <span class="hljs-title">create</span> <span class="hljs-title">ZJMaricle</span></span></code></pre><p>然后会问一些问题</p><pre><code class="hljs sql">What language <span class="hljs-keyword">do</span> you want <span class="hljs-keyword">to</span> <span class="hljs-keyword">use</span>?? [ Swift / ObjC ] &gt; Objc//这里特别说明一下，最好带上demo方便我们以后的代码调试Would you <span class="hljs-keyword">like</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">include</span> a demo application <span class="hljs-keyword">with</span> your <span class="hljs-keyword">library</span>? [ Yes / <span class="hljs-keyword">No</span> ] &gt; YesWhich testing frameworks will you <span class="hljs-keyword">use</span>? [ Specta / Kiwi / <span class="hljs-keyword">None</span> ] &gt; <span class="hljs-keyword">None</span>Would you <span class="hljs-keyword">like</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">do</span> <span class="hljs-keyword">view</span> based testing? [ Yes / <span class="hljs-keyword">No</span> ] &gt; YesWhat <span class="hljs-keyword">is</span> your <span class="hljs-keyword">class</span> prefix? &gt; ZJ</code></pre><p>问完这4个问题他会自动执行pod install命令创建项目并生成依赖。<br>下面是生成的文件目录及介绍</p><pre><code class="hljs reasonml">$ tree ZJMaricle -L <span class="hljs-number">2</span>ZJMaricle├── Example                                            #demo │   ├── Podfile                                        #demo 的依赖描述文件│   ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Podfile</span>.</span></span>lock│   ├── Pods                                           #demo 的依赖文件│   ├── Tests                                           │   ├── ZJMaricle│   ├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ZJMaricle</span>.</span></span>xcodeproj│   └── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ZJMaricle</span>.</span></span>xcworkspace├── LICENSE├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">README</span>.</span></span>md├── ZJMaricle│   ├── Assets                                         #资源文件│   └── Classes                                        #类文件├── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ZJMaricle</span>.</span></span>podspec                                  #podspec pod库的描述文件└── <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_Pods</span>.</span></span>xcodeproj -&gt; Example/Pods/<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Pods</span>.</span></span>xcodeproj<span class="hljs-number">10</span> directories, <span class="hljs-number">5</span> files</code></pre><p>接下来把库文件添加到<code>ZJMaricle/Classes</code>文件夹下，终端进入<code>ZJMaricle/Example</code>下，执行<code>pod update</code>命令,完成后打开项目工程可以看到，刚刚添加的组件已经在Pods子工程下Development Pods/ZJMaricle中了。这里需要注意的是：每次向Pods 中添加文件或者podspec中的版本升级都要执行<code>pod update</code>命令。</p><p>配置podspec文件</p><pre><code class="hljs ruby"><span class="hljs-comment">#</span><span class="hljs-comment"># Be sure to run `pod lib lint ZJMaricle.podspec&#x27; to ensure this is a</span><span class="hljs-comment"># valid spec before submitting.</span><span class="hljs-comment">#</span><span class="hljs-comment"># Any lines starting with a # are optional, but their use is encouraged</span><span class="hljs-comment"># To learn more about a Podspec see http://guides.cocoapods.org/syntax/podspec.html</span><span class="hljs-comment">#</span>Pod::Spec.new <span class="hljs-keyword">do</span> <span class="hljs-params">|s|</span>  s.name             = <span class="hljs-string">&#x27;ZJMaricle&#x27;</span>                              <span class="hljs-comment">#名称</span>  s.version          = <span class="hljs-string">&#x27;0.1.0&#x27;</span>                                  <span class="hljs-comment">#版本号</span>  s.summary          = <span class="hljs-string">&#x27;description of ZJMaricle.&#x27;</span>              <span class="hljs-comment">#库的描述</span><span class="hljs-comment"># This description is used to generate tags and improve search results.</span><span class="hljs-comment">#   * Think: What does it do? Why did you write it? What is the focus?</span><span class="hljs-comment">#   * Try to keep it short, snappy and to the point.</span><span class="hljs-comment">#   * Write the description between the DESC delimiters below.</span><span class="hljs-comment">#   * Finally, don&#x27;t worry about the indent, CocoaPods strips it!</span>  s.description      = &lt;&lt;-DESC<span class="hljs-symbol">TODO:</span> Add long description of the pod here.                       DESC  s.homepage         = <span class="hljs-string">&#x27;https://github.com/MaricleZhang/ZJMaricle.git&#x27;</span> <span class="hljs-comment">#主页,这里要填写可以访问到的地址，不然验证不通过</span>  <span class="hljs-comment"># s.screenshots     = &#x27;www.example.com/screenshots_1&#x27;, &#x27;www.example.com/screenshots_2&#x27;</span>  s.license          = &#123; <span class="hljs-symbol">:type</span> =&gt; <span class="hljs-string">&#x27;MIT&#x27;</span>, <span class="hljs-symbol">:file</span> =&gt; <span class="hljs-string">&#x27;LICENSE&#x27;</span> &#125;  s.author           = &#123; <span class="hljs-string">&#x27;929006968@qq.com&#x27;</span> =&gt; <span class="hljs-string">&#x27;jian.zhang@yuntu-inc.com&#x27;</span> &#125;  s.source           = &#123; <span class="hljs-symbol">:git</span> =&gt; <span class="hljs-string">&#x27;https://github.com/MaricleZhang/ZJMaricle.git&#x27;</span>, <span class="hljs-symbol">:tag</span> =&gt; s.version.to_s &#125;  <span class="hljs-comment">#项目地址，这里不支持ssh的地址，验证不通过，只支持HTTP和HTTPS，最好使用HTTPS</span>  <span class="hljs-comment"># s.social_media_url = &#x27;https://twitter.com/&lt;TWITTER_USERNAME&gt;&#x27;</span>  s.ios.deployment_target = <span class="hljs-string">&#x27;8.0&#x27;</span>  s.source_files = <span class="hljs-string">&#x27;ZJMaricle/Classes/**/*&#x27;</span>                        <span class="hljs-comment">#库文件</span>    <span class="hljs-comment"># s.resource_bundles = &#123;                                         #库资源文件</span>  <span class="hljs-comment">#   &#x27;ZJMaricle&#x27; =&gt; [&#x27;ZJMaricle/Assets/*.png&#x27;]</span>  <span class="hljs-comment"># &#125;</span>  <span class="hljs-comment"># s.public_header_files = &#x27;Pod/Classes/**/*.h&#x27;</span>  <span class="hljs-comment"># s.frameworks = &#x27;UIKit&#x27;, &#x27;MapKit&#x27;</span>  <span class="hljs-comment"># s.dependency &#x27;AFNetworking&#x27;, &#x27;~&gt; 2.3&#x27;</span><span class="hljs-keyword">end</span></code></pre><h3 id="本地测试配置好的podspec文件。"><a href="#本地测试配置好的podspec文件。" class="headerlink" title="本地测试配置好的podspec文件。"></a>本地测试配置好的podspec文件。</h3><p>编辑<code>.podspec</code>完成后本地校验是否合格，这里有必要解释一下<code>pod lib lint</code>校验本地<code>.podspec</code>文件和pod库中的文件的合法性，如果不合法，则需要修改再校验，直到校验通过。如果有警告则需要使用<code>pod lib lint --allow-warnings</code>命令通过校验。</p><pre><code class="hljs crystal">$ pod <span class="hljs-class"><span class="hljs-keyword">lib</span> <span class="hljs-title">lint</span></span></code></pre><p>当出现下面情况时说明本地校验成功</p><pre><code class="hljs angelscript"> -&gt; ZJMaricle (<span class="hljs-number">0.1</span><span class="hljs-number">.0</span>)ZJMaricle passed validation.</code></pre><p>提交代码，我这里使用的<code>sourcetree</code>,本地代码库与远程库建立连接，这里就不在赘述了。并且给远程仓库打上tag，需要注意的是这里的tag就是创建私有库的版本号，需与 <code>.podspec</code>文件中的版本号保持一致。重要的事情说三遍：本地校验成功后在打tag，本地校验成功后在打tag，本地校验成功后在打tag。<br><img src="http://upload-images.jianshu.io/upload_images/2403444-e403c2147ebdea0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="给GitHub仓库打上tag.png"></p><h3 id="向私有的Spec-Repo中提交podspec"><a href="#向私有的Spec-Repo中提交podspec" class="headerlink" title="向私有的Spec Repo中提交podspec"></a>向私有的Spec Repo中提交podspec</h3><p>确认本地校验成功，并且打上tag后，终端进入到<code>ZJMaricle.podspec</code>同一目录下执行</p><pre><code class="hljs avrasm">$ pod repo <span class="hljs-keyword">push</span> ZJMaricleSpec ZJMaricle.podspec  <span class="hljs-meta">#前面是本地Repo名字 后面是podspec名字</span></code></pre><p>出现</p><pre><code class="hljs ocaml">$ pod repo push <span class="hljs-type">ZJMaricleSpec</span> <span class="hljs-type">ZJMaricle</span>.podspec<span class="hljs-type">Validating</span> spec -&gt; <span class="hljs-type">ZJMaricle</span> (<span class="hljs-number">0.1</span>.<span class="hljs-number">0</span>)<span class="hljs-type">Updating</span> the <span class="hljs-type">`ZJMaricleSpec&#x27;</span> repo<span class="hljs-type">Your</span> configuration specifies <span class="hljs-keyword">to</span> merge <span class="hljs-keyword">with</span> the <span class="hljs-built_in">ref</span> <span class="hljs-symbol">&#x27;refs</span>/heads/master&#x27;from the remote, but no such <span class="hljs-built_in">ref</span> was fetched.<span class="hljs-type">Adding</span> the spec <span class="hljs-keyword">to</span> the <span class="hljs-type">`ZJMaricleSpec&#x27;</span> repo - [<span class="hljs-type">Add</span>] <span class="hljs-type">ZJMaricle</span> (<span class="hljs-number">0.1</span>.<span class="hljs-number">0</span>)<span class="hljs-type">Pushing</span> the <span class="hljs-type">`ZJMaricleSpec&#x27;</span> repo</code></pre><p>到索引库Spec Repo远端仓库，会发现有了一次提交，说明podspec已经push上去了，并且索引库已经与代码库建立了有效连接。再到本地的Sepc repo中</p><pre><code class="hljs arcade">$ cd ~<span class="hljs-regexp">/.cocoapods/</span>repos/ZJMaricleSpec</code></pre><p>会发现目录结构变成</p><pre><code class="hljs css"><span class="hljs-selector-tag">ZJMaricle</span>└── 0<span class="hljs-selector-class">.1</span><span class="hljs-selector-class">.0</span>    └── <span class="hljs-selector-tag">ZJMaricle</span><span class="hljs-selector-class">.podspec</span></code></pre><p>到这里pod私有库的创建已经完成，怎么样检验我的pod私有库有没有建立成功呢。执行<code>pod search ZJMaricle</code>出现说明创建成功。</p><pre><code class="hljs awk">-&gt; ZJMaricle (<span class="hljs-number">0.1</span>.<span class="hljs-number">0</span>)   description of ZJMaricle.   pod <span class="hljs-string">&#x27;ZJMaricle&#x27;</span>, <span class="hljs-string">&#x27;~&gt; 0.1.0&#x27;</span>   - Homepage: https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/MaricleZhang/</span>ZJMaricle.git   - Source:   https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/MaricleZhang/</span>ZJMaricle.git   - Versions: <span class="hljs-number">0.1</span>.<span class="hljs-number">0</span> [ZJMaricleSpec repo](<span class="hljs-keyword">END</span>)</code></pre><p>这里讨论的是pod私有库，如果建立共有库的话，请使用 <code>trunk</code>工具,详细请参考<a href="http://guides.cocoapods.org/making/getting-setup-with-trunk.html">官方文档</a>。</p><h2 id="Pod-私有库的使用"><a href="#Pod-私有库的使用" class="headerlink" title="Pod 私有库的使用"></a>Pod 私有库的使用</h2><h3 id="1-私有库的引用"><a href="#1-私有库的引用" class="headerlink" title="1. 私有库的引用"></a>1. 私有库的引用</h3><p>当我们在Example下执行<code>pod install</code> 的时候会出现<code>[!] Unable to find a specification for ZJMaricle </code>,Cocoapods并不能找到对应的私有库。这是因为默认情况下会在公有库<a href="https://github.com/CocoaPods/Specs.git">https://github.com/CocoaPods/Specs.git</a> 中查询，我们的私有库并不在这里，所以当然查询不到。下面是解决的办法，在podfile的顶部添加</p><pre><code class="hljs bash"><span class="hljs-built_in">source</span> <span class="hljs-string">&#x27;https://github.com/CocoaPods/Specs.git&#x27;</span>  <span class="hljs-comment">#官方仓库的地址</span><span class="hljs-built_in">source</span> <span class="hljs-string">&#x27;https://github.com/MaricleZhang/ZJMaricleSpec.git&#x27;</span>  <span class="hljs-comment">#我们自己的私有spec仓库的地址</span></code></pre><p>这里添加的一定为Spec库的地址，如果写成代码库则会出现</p><pre><code class="hljs awk">[!] An unexpected version directory Assets was encountered <span class="hljs-keyword">for</span> the <span class="hljs-regexp">/Users/</span>.cocoapods<span class="hljs-regexp">/repos/m</span>ariclezhang/ZJMaricleSpec Pod <span class="hljs-keyword">in</span> the ZJMaricleSpec repository.</code></pre><h2 id="2-Pod库的校验"><a href="#2-Pod库的校验" class="headerlink" title="2.Pod库的校验"></a>2.Pod库的校验</h2><h4 id="pod-lib-lint-和-pod-spec-lint-命令的区别"><a href="#pod-lib-lint-和-pod-spec-lint-命令的区别" class="headerlink" title="pod lib lint 和 pod spec lint 命令的区别"></a>pod lib lint 和 pod spec lint 命令的区别</h4><p><code> pod lib lint</code>是只从本地验证你的pod能否通过验证<br> <code>pod spec lint</code>是从本地和远程验证你的pod能否通过验证<br>在提交代码之前打tag之前，使用pod lib lint 验证一般不会出现问题，如果出现问题需要验证远程的代码则使用<code>pod spec lint</code>来验证。<br>本地校验<code>pod lib lint</code>如果出现</p><pre><code class="hljs routeros">[!] ZJMaricle did <span class="hljs-keyword">not</span> pass validation, due <span class="hljs-keyword">to</span> 1 <span class="hljs-builtin-name">warning</span> (but you can use `--allow-warnings` <span class="hljs-keyword">to</span> ignore it).</code></pre><p>在代码中警告无法清除时，在提提交代码时使用</p><pre><code class="hljs maxima">pod repo <span class="hljs-built_in">push</span> ZJMaricle ZJMaricleSpec.podspec --allow-<span class="hljs-built_in">warnings</span></code></pre><p>参考文档：<br><a href="http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/">使用Cocoapods创建私有podspec</a><br><a href="http://www.jianshu.com/p/1e5927eeb341">Cocoapods使用私有库中遇到的坑</a><br><a href="http://www.cocoachina.com/ios/20150930/13471.html">Cocoapods 应用第二部分-私有库相关</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS常见控件的封装（二）：UIAlertViewController</title>
    <link href="/2016/10/24/iOS%E5%B8%B8%E8%A7%81%E6%8E%A7%E4%BB%B6%E7%9A%84%E5%B0%81%E8%A3%85%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AUIAlertViewController/"/>
    <url>/2016/10/24/iOS%E5%B8%B8%E8%A7%81%E6%8E%A7%E4%BB%B6%E7%9A%84%E5%B0%81%E8%A3%85%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AUIAlertViewController/</url>
    
    <content type="html"><![CDATA[<blockquote><p>UIAlertViewController类在iOS开发中经常使用，但是使用系统方法需要太多的代码，所以我自己封装了一个类。在一个block中实现点击事件。</p></blockquote><a id="more"></a><ul><li>UIAlertController+Category.h</li></ul><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;UIKit/UIKit.h&gt;</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">void</span> (^CallBackBlock)(<span class="hljs-built_in">NSInteger</span> btnIndex);<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">UIAlertController</span> (<span class="hljs-title">Category</span>)</span><span class="hljs-comment">/**</span><span class="hljs-comment"> 自定义封装的UIAlertController方法</span><span class="hljs-comment"></span><span class="hljs-comment"> @param viewController       显示的vc</span><span class="hljs-comment"> @param alertControllerStyle UIAlertControllerStyle 样式</span><span class="hljs-comment"> @param title                标题</span><span class="hljs-comment"> @param message              提示信息</span><span class="hljs-comment"> @param block                回调block</span><span class="hljs-comment"> @param cancelBtnTitle       取消button标题</span><span class="hljs-comment"> @param destructiveBtnTitle  红色的按钮</span><span class="hljs-comment"> @param otherBtnTitles       其他button标题</span><span class="hljs-comment"> */</span>+ (<span class="hljs-keyword">void</span>)showAlertCntrollerWithViewController:(<span class="hljs-built_in">UIViewController</span>*)viewController alertControllerStyle:(<span class="hljs-built_in">UIAlertControllerStyle</span>)alertControllerStyle title:(<span class="hljs-built_in">NSString</span>*)title message:(<span class="hljs-built_in">NSString</span>*)message CallBackBlock:(CallBackBlock)block cancelButtonTitle:(<span class="hljs-built_in">NSString</span> *)cancelBtnTitle                    destructiveButtonTitle:(<span class="hljs-built_in">NSString</span> *)destructiveBtnTitle                         otherButtonTitles:(<span class="hljs-built_in">NSString</span> *)otherBtnTitles,...NS_REQUIRES_NIL_TERMINATION;<span class="hljs-keyword">@end</span></code></pre><ul><li>UIAlertController+Category.h</li></ul><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-meta-string">&quot;UIAlertController+Category.h&quot;</span></span><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">UIAlertController</span> (<span class="hljs-title">Category</span>)</span>+(<span class="hljs-keyword">void</span>)showAlertCntrollerWithViewController:(<span class="hljs-built_in">UIViewController</span> *)viewController alertControllerStyle:(<span class="hljs-built_in">UIAlertControllerStyle</span>)alertControllerStyle title:(<span class="hljs-built_in">NSString</span> *)title message:(<span class="hljs-built_in">NSString</span> *)message CallBackBlock:(CallBackBlock)block cancelButtonTitle:(<span class="hljs-built_in">NSString</span> *)cancelBtnTitle destructiveButtonTitle:(<span class="hljs-built_in">NSString</span> *)destructiveBtnTitle otherButtonTitles:(<span class="hljs-built_in">NSString</span> *)otherBtnTitles, ...&#123;    <span class="hljs-built_in">UIAlertController</span> * alertController = [<span class="hljs-built_in">UIAlertController</span> alertControllerWithTitle:title message:message preferredStyle:alertControllerStyle];    <span class="hljs-comment">//添加按钮</span>    <span class="hljs-keyword">if</span> (cancelBtnTitle.length) &#123;        <span class="hljs-built_in">UIAlertAction</span> * cancelAction = [<span class="hljs-built_in">UIAlertAction</span> actionWithTitle:cancelBtnTitle style:<span class="hljs-built_in">UIAlertActionStyleCancel</span> handler:^(<span class="hljs-built_in">UIAlertAction</span> * _Nonnull action) &#123;            block(<span class="hljs-number">0</span>);        &#125;];        [alertController addAction:cancelAction];    &#125;    <span class="hljs-keyword">if</span> (destructiveBtnTitle.length) &#123;        <span class="hljs-built_in">UIAlertAction</span> * destructiveAction = [<span class="hljs-built_in">UIAlertAction</span> actionWithTitle:destructiveBtnTitle style:<span class="hljs-built_in">UIAlertActionStyleDestructive</span> handler:^(<span class="hljs-built_in">UIAlertAction</span> * _Nonnull action) &#123;            block(<span class="hljs-number">1</span>);        &#125;];        [alertController addAction:destructiveAction];    &#125;    <span class="hljs-keyword">if</span> (otherBtnTitles.length) &#123;        <span class="hljs-built_in">UIAlertAction</span> *otherActions = [<span class="hljs-built_in">UIAlertAction</span> actionWithTitle:otherBtnTitles style:<span class="hljs-built_in">UIAlertActionStyleDefault</span> handler:^(<span class="hljs-built_in">UIAlertAction</span> *action) &#123;            (!cancelBtnTitle.length &amp;&amp; !destructiveBtnTitle.length) ? block(<span class="hljs-number">0</span>) : (((cancelBtnTitle.length &amp;&amp; !destructiveBtnTitle.length) || (!cancelBtnTitle.length &amp;&amp; destructiveBtnTitle.length)) ? block(<span class="hljs-number">1</span>) : block(<span class="hljs-number">2</span>));        &#125;];        [alertController addAction:otherActions];        <span class="hljs-comment">/**</span><span class="hljs-comment">         *  va_list : （1）首先在函数里定义一具VA_LIST型的变量，这个变量是指向参数的指针；</span><span class="hljs-comment">         *            （2）然后用VA_START宏初始化变量刚定义的VA_LIST变量；</span><span class="hljs-comment">         *            （3）然后用VA_ARG返回可变的参数，VA_ARG的第二个参数是你要返回的参数的类型（如果函数有多个可变参数的，依次调用VA_ARG获取各个参数）；</span><span class="hljs-comment">         *            （4）最后用VA_END宏结束可变参数的获取。</span><span class="hljs-comment">         *   va_start :获取可变参数列表的第一个参数的地址;</span><span class="hljs-comment">         *   va_arg :获取当前参数，返回指定类型并将指针指向下一参数</span><span class="hljs-comment">         *   va_end :清空va_list可变参数列表：</span><span class="hljs-comment">         *</span><span class="hljs-comment">         *</span><span class="hljs-comment">         */</span>        va_list args;        va_start(args, otherBtnTitles);        <span class="hljs-keyword">if</span> (otherBtnTitles.length) &#123;            <span class="hljs-built_in">NSString</span> * otherString;            <span class="hljs-keyword">int</span> index = <span class="hljs-number">2</span>;            (!cancelBtnTitle.length &amp;&amp; !destructiveBtnTitle.length) ? (index = <span class="hljs-number">0</span>) : ((cancelBtnTitle.length &amp;&amp; !destructiveBtnTitle.length) || (!cancelBtnTitle.length &amp;&amp; destructiveBtnTitle.length) ? (index = <span class="hljs-number">1</span>) : (index = <span class="hljs-number">2</span>));            <span class="hljs-keyword">while</span> ((otherString = va_arg(args, <span class="hljs-built_in">NSString</span>*))) &#123;                index ++ ;                <span class="hljs-built_in">UIAlertAction</span> * otherActions = [<span class="hljs-built_in">UIAlertAction</span> actionWithTitle:otherString style:<span class="hljs-built_in">UIAlertActionStyleDefault</span> handler:^(<span class="hljs-built_in">UIAlertAction</span> * _Nonnull action) &#123;                    block(index);                &#125;];                [alertController addAction:otherActions];            &#125;        &#125;        va_end(args);    &#125;    [viewController presentViewController:alertController animated:<span class="hljs-literal">YES</span> completion:<span class="hljs-literal">nil</span>];&#125;<span class="hljs-keyword">@end</span></code></pre><p>其实主要的难点就是循环获取otherButtons,代码中有详细的介绍，不足之处希望大家指正。想要了解更多或者下载demo,请访问github:<a href="https://github.com/Maricle1/ControlsPackage.git">https://github.com/Maricle1/ControlsPackage.git</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>iOS常见控件的封装（一）：UIButton</title>
    <link href="/2016/10/17/iOS%E5%B8%B8%E8%A7%81%E6%8E%A7%E4%BB%B6%E7%9A%84%E5%B0%81%E8%A3%85%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AUIButton/"/>
    <url>/2016/10/17/iOS%E5%B8%B8%E8%A7%81%E6%8E%A7%E4%BB%B6%E7%9A%84%E5%B0%81%E8%A3%85%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AUIButton/</url>
    
    <content type="html"><![CDATA[<blockquote><p>UIButton类在使用时需要一行行的来设置属性，代码过于冗余。每个点击事件都要创建一个方法，不利于阅读。下面就是我用block封装的UIButton的分类。</p></blockquote><a id="more"></a><ul><li>UIButton+Block.h</li></ul><pre><code class="hljs objectivec"> <span class="hljs-meta">#import <span class="hljs-meta-string">&lt;UIKit/UIKit.h&gt;</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">void</span>(^tapActionBlock)(<span class="hljs-built_in">UIButton</span> *button);<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">UIButton</span> (<span class="hljs-title">Block</span>)</span><span class="hljs-keyword">@property</span>(<span class="hljs-keyword">nonatomic</span>,<span class="hljs-keyword">copy</span>)tapActionBlock actionBlock;<span class="hljs-comment">/**</span><span class="hljs-comment"> 通过block对button的点击事件封装</span><span class="hljs-comment"> </span><span class="hljs-comment"> @param frame       frame</span><span class="hljs-comment"> @param title       标题</span><span class="hljs-comment"> @param bgImageName 背景图片</span><span class="hljs-comment"> @param actionBlock 点击事件回调block</span><span class="hljs-comment"> </span><span class="hljs-comment"> @return button</span><span class="hljs-comment"> */</span>+ (<span class="hljs-built_in">UIButton</span> *)createBtnFrame:(<span class="hljs-built_in">CGRect</span>)frame title:(<span class="hljs-built_in">NSString</span> *)title bgImageName:(<span class="hljs-built_in">NSString</span> *)bgImageName action:(tapActionBlock)actionBlock;<span class="hljs-keyword">@end</span></code></pre><ul><li>UIButton+Block.m</li></ul><pre><code class="hljs objectivec"><span class="hljs-meta">#import <span class="hljs-meta-string">&quot;UIButton+Block.h&quot;</span></span><span class="hljs-meta">#import <span class="hljs-meta-string">&lt;objc/runtime.h&gt;</span></span><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">UIButton</span> (<span class="hljs-title">Block</span>)</span><span class="hljs-keyword">static</span> <span class="hljs-built_in">NSString</span> *keyOfUseCategoryMethod;<span class="hljs-comment">//用分类方法创建的button，关联对象的key</span><span class="hljs-keyword">static</span> <span class="hljs-built_in">NSString</span> *keyOfBlock;+ (<span class="hljs-built_in">UIButton</span> *)createBtnFrame:(<span class="hljs-built_in">CGRect</span>)frame title:(<span class="hljs-built_in">NSString</span> *)title bgImageName:(<span class="hljs-built_in">NSString</span> *)bgImageName action:(tapActionBlock)actionBlock&#123;        <span class="hljs-built_in">UIButton</span> *button = [<span class="hljs-built_in">UIButton</span> buttonWithType:<span class="hljs-built_in">UIButtonTypeRoundedRect</span>];    button.frame = frame;    [button setTitle:title forState:<span class="hljs-built_in">UIControlStateNormal</span>];    [button setBackgroundImage:[<span class="hljs-built_in">UIImage</span> imageNamed:bgImageName] forState:<span class="hljs-built_in">UIControlStateNormal</span>];    [button addTarget:button action:<span class="hljs-keyword">@selector</span>(tapAction:) forControlEvents:<span class="hljs-built_in">UIControlEventTouchUpInside</span>];        <span class="hljs-comment">/**</span><span class="hljs-comment">     *用runtime中的函数通过key关联对象</span><span class="hljs-comment">     *</span><span class="hljs-comment">     *objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)</span><span class="hljs-comment">     *id object                     表示关联者，是一个对象，变量名理所当然也是object</span><span class="hljs-comment">     *const void *key               获取被关联者的索引key</span><span class="hljs-comment">     *id value                      被关联者，这里是一个block</span><span class="hljs-comment">     *objc_AssociationPolicy policy 关联时采用的协议，有assign，retain，copy等协议，一般使用OBJC_ASSOCIATION_RETAIN_NONATOMIC</span><span class="hljs-comment">     </span><span class="hljs-comment">     */</span>    objc_setAssociatedObject (button , &amp;keyOfUseCategoryMethod , actionBlock, OBJC_ASSOCIATION_COPY_NONATOMIC );        <span class="hljs-keyword">return</span> button;&#125;- (<span class="hljs-keyword">void</span>)tapAction:(<span class="hljs-built_in">UIButton</span>*)sender&#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 通过key获取被关联对象</span><span class="hljs-comment">     *objc_getAssociatedObject(id object, const void *key)</span><span class="hljs-comment">     *</span><span class="hljs-comment">     */</span>    tapActionBlock block = ( tapActionBlock )objc_getAssociatedObject (sender , &amp;keyOfUseCategoryMethod );        <span class="hljs-keyword">if</span> (block) &#123;                block(sender);            &#125;&#125;- (<span class="hljs-keyword">void</span>)setActionBlock:(tapActionBlock)actionBlock&#123;    objc_setAssociatedObject (<span class="hljs-keyword">self</span> , &amp;keyOfBlock , actionBlock, OBJC_ASSOCIATION_COPY_NONATOMIC );    &#125;- (tapActionBlock)actionBlock&#123;    <span class="hljs-keyword">return</span> objc_getAssociatedObject (<span class="hljs-keyword">self</span> , &amp;keyOfBlock );&#125;<span class="hljs-keyword">@end</span></code></pre><p>这个封装的主要难点在于用runtime关联block，代码注释中有详细的解释，不足之处希望大家指正。想要了解更多或者下载demo,请访问github:<a href="https://github.com/Maricle1/ControlsPackage.git">https://github.com/Maricle1/ControlsPackage.git</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
